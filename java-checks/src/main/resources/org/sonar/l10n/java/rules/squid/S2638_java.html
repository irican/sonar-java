<p>因为子类实例可以被转换为超类的实例并被视为超类的实例，所以覆盖方法应该维护超类契约中与Liskov替换原则相关的部分。具体来说，如果超类方法的参数或返回类型被标记为以下任何一种：
<code>@Nullable</code>，<code>@CheckForNull</code>，<code>@NotNull</code>，<code>@NonNull</code>，和<code>@Nonnull</code>，那么子类参数不允许收紧契约，返回值也不允许放松契约。</p>
<h2>不合规的代码示例</h2>
<pre>
public class Fruit {

  private Season ripe;
  private String color;

  public void setRipe(@Nullable Season ripe) {
    this.ripe = ripe;
  }

  public @NotNull Integer getProtein() {
    return 12;
  }
}

public class Raspberry extends Fruit {

  public void setRipe(@NotNull Season ripe) {  // 不合规
    this.ripe = ripe;
  }

  public @Nullable Integer getProtein() {  // 不合规
    return null;
  }
}
</pre>
<h2>请参阅</h2>
<ul>
  <li> https://en.wikipedia.org/wiki/Liskov_substitution_principle </li>
</ul>

