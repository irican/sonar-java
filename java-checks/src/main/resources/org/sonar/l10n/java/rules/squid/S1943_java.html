<p>使用依赖于默认系统编码的类和方法可以生成在其“home”环境中工作良好的代码。但是，对于使用不同编码方式的客户来说，代码可能会破坏，
这些编码方式非常难以诊断，而且在需要修复它们的时候，几乎不可能重现。</p>
<p>此规则检测以下类和方法的使用：</p>
<ul>
  <li> <code>FileReader</code> </li>
  <li> <code>FileWriter</code> </li>
  <li> 带有 <code>byte[]</code> 参数但没有 <code>Charset</code> 参数的字符串构造函数
    <ul>
      <li> <code>String(byte[] bytes)</code> </li>
      <li> <code>String(byte[] bytes, int offset, int length)</code> </li>
    </ul> </li>
  <li> <code>String.getBytes()</code> </li>
  <li> <code>String.getBytes(int srcBegin, int srcEnd, byte[] dst, int dstBegin)</code> </li>
  <li> <code>InputStreamReader(InputStream in)</code> </li>
  <li> <code>OutputStreamWriter(OutputStream out)</code> </li>
  <li> <code>ByteArrayOutputStream.toString()</code> </li>
  <li> 一些 <code>Formatter</code> 构造函数
    <ul>
      <li> <code>Formatter(String fileName)</code> </li>
      <li> <code>Formatter(File file)</code> </li>
      <li> <code>Formatter(OutputStream os)</code> </li>
    </ul> </li>
  <li> 一些 <code>Scanner</code> 构造函数
    <ul>
      <li> <code>Scanner(File source)</code> </li>
      <li> <code>Scanner(Path source)</code> </li>
      <li> <code>Scanner(InputStream source)</code> </li>
    </ul> </li>
  <li> 一些 <code>PrintStream</code> 构造函数
    <ul>
      <li> <code>PrintStream(File file)</code> </li>
      <li> <code>PrintStream(OutputStream out)</code> </li>
      <li> <code>PrintStream(OutputStream out, boolean autoFlush)</code> </li>
      <li> <code>PrintStream(String fileName)</code> </li>
    </ul> </li>
  <li> 一些 <code>PrintWriter</code> 构造函数
    <ul>
      <li> <code>PrintWriter(File file)</code> </li>
      <li> <code>PrintWriter(OutputStream out)</code> </li>
      <li> <code>PrintWriter(OutputStream out, boolean autoFlush)</code> </li>
      <li> <code>PrintWriter(String fileName)</code> </li>
    </ul> </li>
  <li> 来自Apache commons-io库的方法，当编码参数为空时，这些方法接受编码参数，并重载那些省略编码参数的方法
    <ul>
      <li> <code>IOUtils.copy(InputStream, Writer)</code> </li>
      <li> <code>IOUtils.copy(Reader, OutputStream)</code> </li>
      <li> <code>IOUtils.readLines(InputStream)</code> </li>
      <li> <code>IOUtils.toByteArray(Reader)</code> </li>
      <li> <code>IOUtils.toByteArray(String)</code> </li>
      <li> <code>IOUtils.toCharArray(InputStream)</code> </li>
      <li> <code>IOUtils.toInputStream(TypeCriteria.subtypeOf(CharSequence))</code> </li>
      <li> <code>IOUtils.toString(byte[])</code> </li>
      <li> <code>IOUtils.toString(URI)</code> </li>
      <li> <code>IOUtils.toString(URL)</code> </li>
      <li> <code>IOUtils.write(char[], OutputStream)</code> </li>
      <li> <code>IOUtils.write(CharSequence, OutputStream)</code> </li>
      <li> <code>IOUtils.writeLines(Collection, String, OutputStream)</code> </li>
      <li> <code>FileUtils.readFileToString(File)</code> </li>
      <li> <code>FileUtils.readLines(File)</code> </li>
      <li> <code>FileUtils.write(File, CharSequence)</code> </li>
      <li> <code>FileUtils.write(File, CharSequence, boolean)</code> </li>
      <li> <code>FileUtils.writeStringToFile(File, String)</code> </li>
    </ul> </li>
</ul>
<h2>请参阅</h2>
<ul>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/FoL5AQ">CERT, STR04-J.</a> - Use compatible character encodings when communicating
  string data between JVMs </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/JgAWCQ">CERT, STR50-J.</a> - Use the appropriate method for counting characters in a
  string </li>
</ul>

