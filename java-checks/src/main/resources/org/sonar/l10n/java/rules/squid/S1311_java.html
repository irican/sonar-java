<p>对于类中的每个构造函数，方法，静态初始化程序或实例初始化程序来说，环路复杂度（Cyclomatic Complexity）
是通过类的主体中的 <code>&amp;&amp;</code> 和 <code>||</code> 运算符的数量和 <code>if</code>，<code>while</code>， <code>do</code>， <code>for</code>， 
<code>?:</code>， <code>catch</code>， <code>switch</code>， <code>case</code>，<code>return</code> 和 <code>throw</code> 每个语句加1来计算的，
方法中的最后一个return语句（如果存在）不会被考虑在内。</p>
<p>即使类的环路复杂度非常高，这种复杂度也可以很好地分布在所有方法中。然而，在大多数情况下，一个非常复杂的类会打破单一责任原则，
它应该被重构为多个类。</p>
<h2>弃用</h2>
<p>此规则已弃用，最终将被删除。</p>

