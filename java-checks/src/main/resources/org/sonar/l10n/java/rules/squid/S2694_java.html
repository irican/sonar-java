<p>非静态内部类具有对其外部类的引用，并访问外部类的字段和方法。这个类引用会使内部类变大，并可能导致外部类实例在内存中驻留的时间超过必要的时间。</p>
<p>如果没有使用对外部类的引用，则使内部类<code>static</code> (也称为嵌套类)更有效。如果引用只在类构造函数中使用，则显式地将类引用传递给构造函数。
如果内部类是匿名的，那么也需要为它命名。</p>
<p>然而，虽然嵌套的/<code>static</code>类会更有效，但值得注意的是，内部类和嵌套类之间存在语义差异：</p>
<ul>
  <li> 内部类只能在外部类的实例上下文中实例化。 </li>
  <li> 嵌套类(<code>static</code>)可以独立于外部类实例化。</li>
</ul>
<h2>不合规的代码示例</h2>
<pre>
public class Fruit {
  // ...

  public class Seed {  // 不合规；没有使用外部类引用，所以将它设置为静态
    int germinationDays = 0;
    public Seed(int germinationDays) {
      this.germinationDays = germinationDays;
    }
    public int getGerminationDays() {
      return germinationDays;
    }
  }
}
</pre>
<h2>合规的解决方案</h2>
<pre>
public class Fruit {
  // ...

  public static class Seed {
    int germinationDays = 0;
    public Seed(int germinationDays) {
      this.germinationDays = germinationDays;
    }
    public int getGerminationDays() {
      return germinationDays;
    }
  }
}
</pre>

