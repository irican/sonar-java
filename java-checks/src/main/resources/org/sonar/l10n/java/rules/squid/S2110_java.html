<p><code>Date</code> 字段的有效值范围是以0或1开始的，随字段的不同而不同。例如，month从0开始，day of month从1开始。输入超过有效范围结束的日期值，
日期将滚动而不会出现错误或异常。例如，输入12表示month，您将获得次年的1月份。</p>
<p>此规则检查与 <code>java.util.Date</code>， <code>java.sql.Date</code>， 和 <code>java.util.Calendar</code>一起使用的错误值。
具体而言，有效范围之外的值：</p>
<table>
  <tbody>
    <tr>
      <th>Field</th>
      <th>Valid</th>
    </tr>
    <tr>
      <td>month</td>
      <td>0-11</td>
    </tr>
    <tr>
      <td>date (day)</td>
      <td>0-31</td>
    </tr>
    <tr>
      <td>hour</td>
      <td>0-23</td>
    </tr>
    <tr>
      <td>minute</td>
      <td>0-60</td>
    </tr>
    <tr>
      <td>second</td>
      <td>0-61</td>
    </tr>
  </tbody>
</table>
<p>请注意，此规则不会检查无效的闰年，闰秒（秒= 61）或该月31日的无效使用。</p>
<h2>不合规的代码示例</h2>
<pre>
Date d = new Date();
d.setDate(25);
d.setYear(2014);
d.setMonth(12);  // 不合规； d 到了下一年

Calendar c = new GregorianCalendar(2014, 12, 25);  // 不合规
if (c.get(Calendar.MONTH) == 12) {  // 不合规； 无效的比较
  // ...
}
</pre>
<h2>合规的解决方案</h2>
<pre>
Date d = new Date();
d.setDate(25);
d.setYear(2014);
d.setMonth(11);

Calendar c = new Gregorian Calendar(2014, 11, 25);
if (c.get(Calendar.MONTH) == 11) {
  // ...
}
</pre>

