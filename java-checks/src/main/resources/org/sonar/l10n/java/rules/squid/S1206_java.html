<p>根据Java语言规范，<code>equals(Object)</code> 和 <code>hashCode()</code>之间存在契约：</p>
<blockquote>
  <p>根据 <code>equals(Object)</code> 方法，如果两个对象相等，那么在每个对象上调用 <code>hashCode</code> 方法必须产生相同的整数结果。 </p>
  <p>而根据 <code>equals(java.lang.Object)</code> 方法，如果两个对象不相等，那么并不需要在每个对象上调用 <code>hashCode</code> 方法必须产生不同的整数结果。</p>
  <p>但是，程序员应该意识到，为不相等的对象生成不同的整数结果可能会提高哈希表的性能。</p>
</blockquote>
<p>为了遵守这个契约，这些方法要么被继承，要么被重写。</p>
<h2>不合规的代码示例</h2>
<pre>
class MyClass {    // 不合规 - 还应该重写 "hashCode()"

  @Override
  public boolean equals(Object obj) {
    /* ... */
  }

}
</pre>
<h2>合规的解决方案</h2>
<pre>
class MyClass {    // 合规的

  @Override
  public boolean equals(Object obj) {
    /* ... */
  }

  @Override
  public int hashCode() {
    /* ... */
  }

}
</pre>
<h2>请参阅</h2>
<ul>
  <li> <a href="http://cwe.mitre.org/data/definitions/581.html">MITRE, CWE-581</a> - Object Model Violation: Just One of Equals and Hashcode Defined
  </li>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/EYYbAQ">CERT, MET09-J.</a> - Classes that define an equals() method must also define a
  hashCode() method </li>
</ul>

