<p><code>java.util.concurrent.locks.Lock</code>提供了比<code>synchronized</code> 块更强大，更灵活的锁定操作。因此在<code>Lock</code> 上同步会浪费对象的能力，这很愚蠢。
相反，应该使用 <code>tryLock()</code> 和 <code>unlock()</code>来锁定和解锁这些对象。</p>
<h2>不合规的代码示例</h2>
<pre>
Lock lock = new MyLockImpl();
synchronized(lock) {  // 不合规
  //...
}
</pre>
<h2>合规的解决方案</h2>
<pre>
Lock lock = new MyLockImpl();
lock.tryLock();
//...
</pre>
<h2>请参阅</h2>
<ul>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/cQCaAg">CERT, LCK03-J.</a> - Do not synchronize on the intrinsic locks of high-level
  concurrency objects </li>
</ul>

