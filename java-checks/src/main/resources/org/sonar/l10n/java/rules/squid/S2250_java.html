<p>方法调用集合的时间复杂性并不总是很明显。例如，对于大多数集合， <code>size()</code> 方法需要恒定的时间，但执行 <code>ConcurrentLinkedQueue.size()</code> 所需的时间是O（n），即与集合中的元素数量。当收集很大时，这可能是昂贵的操作。 </p>
<p>当在类字段上的构造函数之外调用以下O（n）方法时，此规则引发了一个问题：</p>
<ul>
  <li> <code>ArrayList</code>
    <ul>
      <li> <code>contains</code> </li>
      <li> <code>remove</code> </li>
    </ul> </li>
  <li> <code>LinkedList</code>
    <ul>
      <li> <code>get</code> </li>
      <li> <code>contains</code> </li>
    </ul> </li>
  <li> <code>ConcurrentLinkedQueue</code>
    <ul>
      <li> <code>size</code> </li>
      <li> <code>contains</code> </li>
    </ul> </li>
  <li> <code>ConcurrentLinkedDeque</code>
    <ul>
      <li> <code>size</code> </li>
      <li> <code>contains</code> </li>
    </ul> </li>
  <li> <code>CopyOnWriteArrayList</code>
    <ul>
      <li> <code>add</code> </li>
      <li> <code>contains</code> </li>
      <li> <code>remove</code> </li>
    </ul> </li>
  <li> <code>CopyOnWriteArraySet</code>
    <ul>
      <li> <code>add</code> </li>
      <li> <code>contains</code> </li>
      <li> <code>remove</code> </li>
    </ul> </li>
</ul>
<h2>不符合规范的代码示例</h2>
<pre>
ConcurrentLinkedQueue queue = new ConcurrentLinkedQueue();
//...
log.info("Queue contains " + queue.size() + " elements");  // 不合规
</pre>

