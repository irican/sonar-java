<p>对于小数字， <code>float</code> 类型有足够的精度来产生期望值，但是对于较大的数字，它不会。
<code>BigDecimal</code> 是最好的选择，但是如果需要原始类型 ，使用 <code>double</code>。</p>
<h2>不合规的代码示例</h2>
<pre>
float a = 16777216.0f;
float b = 1.0f;
float c = a + b; // 不合规；产生 1.6777216E7 而不是  1.6777217E7

double d = a + b; // 不合规； 加号仍然在两个浮点数之间 
</pre>
<h2>合规的解决方案</h2>
<pre>
float a = 16777216.0f;
float b = 1.0f;
BigDecimal c = BigDecimal.valueOf(a).add(BigDecimal.valueOf(b));

double d = (double)a + (double)b;
</pre>
<h2>例外</h2>
<p>当数学表达式仅用于构建字符串时，此规则不会报告问题。</p>
<pre>
System.out.println("["+getName()+"] " +
           "\n\tMax time to retrieve connection:"+(max/1000f/1000f)+" ms.");
</pre>
<h2>请参阅</h2>
<ul>
  <li> <a href="https://www.securecoding.cert.org/confluence/x/DgU">CERT, FLP02-C.</a> - Avoid using floating-point numbers when precise computation
  is needed </li>
</ul>

